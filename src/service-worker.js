import { build, files, version } from "$service-worker";
// `build` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory

const cacheName = `cache${version}`;

const toCache = build.concat(files);

self.addEventListener("install", (event) => {
	console.log("installing service worker");

	event.waitUntil(
		caches.open(cacheName).then((cache) => {
			// Cache all static assets and bundler files
			return cache.addAll(toCache);
		})
	);

	console.log("Successfully Cached assets and bundler files.");
});

self.addEventListener("fetch", (event) => {
	// Check if this is a request for an image
	if (event.request.destination === "image") {
		event.respondWith(
			caches.open(cacheName).then((cache) => {
				// Go to the cache first
				return cache.match(event.request.url).then((cachedResponse) => {
					// Return a cached response if we have one
					if (cachedResponse) {
						return cachedResponse;
					}

					// Otherwise, hit the network
					return fetch(event.request).then((fetchedResponse) => {
						// Add the network response to the cache for later visits
						cache.put(event.request, fetchedResponse.clone());

						// Return the network response
						return fetchedResponse;
					});
				});
			})
		);
	} else {
		return;
	}
});

// Offline Capabilities

// This is the service worker with the combined offline experience (Offline page + Offline copy of pages)

const CACHE = "offline-page";

importScripts("https://storage.googleapis.com/workbox-cdn/releases/5.1.2/workbox-sw.js");

const offlineFallbackPage = "offlineFallback.html";

self.addEventListener("message", (event) => {
	if (event.data && event.data.type === "SKIP_WAITING") {
		self.skipWaiting();
	}
});

self.addEventListener("install", async (event) => {
	event.waitUntil(caches.open(CACHE).then((cache) => cache.add(offlineFallbackPage)));
});

if (workbox.navigationPreload.isSupported()) {
	workbox.navigationPreload.enable();
}

workbox.routing.registerRoute(
	new RegExp("/*"),
	new workbox.strategies.StaleWhileRevalidate({
		cacheName: CACHE
	})
);

self.addEventListener("fetch", (event) => {
	if (event.request.mode === "navigate") {
		event.respondWith(
			(async () => {
				try {
					const preloadResp = await event.preloadResponse;

					if (preloadResp) {
						return preloadResp;
					}

					const networkResp = await fetch(event.request);
					return networkResp;
				} catch (error) {
					const cache = await caches.open(CACHE);
					const cachedResp = await cache.match(offlineFallbackPage);
					return cachedResp;
				}
			})()
		);
	}
});
