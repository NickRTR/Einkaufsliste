import { build, files, version } from "$service-worker";
// `build` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory

importScripts("https://storage.googleapis.com/workbox-cdn/releases/5.1.2/workbox-sw.js");

const cacheName = `cache${version}`;

const offlineCache = "offline-page";
const offlineFallbackPage = "offlineFallback.html";

const toCache = build.concat(files);

self.addEventListener("install", (event) => {
	console.log("installing service worker");

	event.waitUntil(
		caches.open(cacheName).then((cache) => {
			// Cache all static assets and bundler files
			return cache.addAll(toCache);
		})
	);

	// offline page
	event.waitUntil(caches.open(CACHE).then((cache) => cache.add(offlineFallbackPage)));

	console.log("Successfully Cached assets and bundler files.");
});

self.addEventListener("fetch", (event) => {
	// Check if this is a request for an image
	if (event.request.destination === "image") {
		event.respondWith(
			caches.open(cacheName).then((cache) => {
				// Go to the cache first
				return cache.match(event.request.url).then((cachedResponse) => {
					// Return a cached response if we have one
					if (cachedResponse) {
						return cachedResponse;
					}

					// Otherwise, hit the network
					return fetch(event.request).then((fetchedResponse) => {
						// Add the network response to the cache for later visits
						cache.put(event.request, fetchedResponse.clone());

						// Return the network response
						return fetchedResponse;
					});
				});
			})
		);

		// navigation
		if (event.request.mode === "navigate") {
			event.respondWith(
				(async () => {
					try {
						const preloadResp = await event.preloadResponse;

						if (preloadResp) {
							return preloadResp;
						}

						const networkResp = await fetch(event.request);
						return networkResp;
					} catch (error) {
						const cache = await caches.open(CACHE);
						const cachedResp = await cache.match(offlineFallbackPage);
						return cachedResp;
					}
				})()
			);
		}
	} else {
		return;
	}
});

self.addEventListener("message", (event) => {
	if (event.data && event.data.type === "SKIP_WAITING") {
		self.skipWaiting();
	}
});

if (workbox.navigationPreload.isSupported()) {
	workbox.navigationPreload.enable();
}

workbox.routing.registerRoute(
	new RegExp("/*"),
	new workbox.strategies.StaleWhileRevalidate({
		cacheName: offlineCache
	})
);
